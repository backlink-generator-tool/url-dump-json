<script>
/* Injects a stealthIFrameContainer into the current page (no need for a manual <div>)
   Supports random submissions to web.archive.org, ghostarchive.org, and archive.today.
*/

const fetchData = [
    "http://folllike.com/?19384926",
    "https://www.followlike.info/?r=19384926",
    "https://www.followlike.net/?r=19384926",
    "https://www.like4like.org/?ref=new_account",
    "https://www.like4like.org/buy-instagram-likes.php?ref=new_account",
    "https://www.hit4hit.org/?ref=mart192a",
    "https://www.10khits.com/?ref=319049",
    "https://rankboostup.com/?refid=510070",
    "https://www.nice-autosurf.com/parrain-256003.html",
    "https://objectivesocial.com/?ref=392",
    "https://objectivecoin.com/?ref=22",
    "https://2pink.org/dang-ky?ref=119334",
    "https://livetraffic.net/login?refer=119334",
    "https://2pink.org/dang-ky?ref=123215",
    "https://livetraffic.net/login?refer=123215",
    "https://www.ytmonster.net/r/NewAccount",
    "https://www.followlike.info/splash.php?r=19384926",
    "https://www.followlike.info/splashvid.php?r=19384926",
    "https://www.followlike.net/splash.php?r=19384926",
    "https://www.followlike.net/splashvid.php?r=19384926",
    "https://ylkhts.cc/?id=3509858",
    "https://www.youlikehits.com/?id=3509858",
    "http://kingdomlikes.com/?ref=AMUaOjUA2J",
    "https://likestool.com/ref/5KLun5m",
    "https://www.linkcollider.com/page/register?r=544188&aff=1",
    "http://follow4follow.com/?ref=235864",
    "https://bighits4u.com/by/wireconnected",
    "https://everve.net/ref/343736/"
];
const fetchURLs = [
	"https://backlink-generator-tool.github.io/url-dump-json/url/custom-urls/backlink-generator.json"
];

const IFRAME_COUNT = 4;
const SUBMIT_INTERVAL = 60000; // 60s

function isValidURL(url) {
  const pattern = /^https?:\/\/[^\s]+$/i;
  return pattern.test(url);
}
function shuffle(array){ for(let i=array.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[array[i],array[j]]=[array[j],array[i]];} }
function normalizeURL(url){ if(typeof url!=='string') return ""; return url.replace(/([^:]\/)\/+/g,"$1"); }
function randomURL(array){ return array[Math.floor(Math.random()*array.length)]; }

/* ============================================================
     ðŸ”¥ HARDENED updateDefaultURLs() â€” robust JS + JSON support
   ============================================================ */
async function updateDefaultURLs() {
  // small sleep helper
  const wait = (ms) => new Promise(res => setTimeout(res, ms));

  // import module from text using blob URL
  async function importModuleFromText(jsText) {
    const blob = new Blob([jsText], { type: 'application/javascript' });
    const blobUrl = URL.createObjectURL(blob);
    try {
      return await import(blobUrl);
    } finally {
      URL.revokeObjectURL(blobUrl);
    }
  }

  // extract possible arrays from JSON payloads
  function extractFromJSON(data) {
    if (Array.isArray(data)) return data.slice();
    for (const key of ['urls','items','data','list']) {
      if (Array.isArray(data?.[key])) return data[key].slice();
    }
    // fallback: first array property
    if (data && typeof data === 'object') {
      for (const k of Object.keys(data)) if (Array.isArray(data[k])) return data[k].slice();
    }
    return [];
  }

  // extract arrays from imported modules (common shapes)
  async function extractFromModule(mod) {
    if (!mod) return [];
    if (Array.isArray(mod.default)) return mod.default.slice();
    for (const key of ['urls','items','data','list','pins','pinIds']) {
      if (Array.isArray(mod[key])) return mod[key].slice();
    }
    for (const fn of ['build','load','get']) {
      if (typeof mod[fn] === 'function') {
        try {
          const out = await mod[fn]();
          if (Array.isArray(out)) return out.slice();
        } catch(e){ /* ignore and continue */ }
      }
    }
    return [];
  }

  // script fallback that waits for globals, an event, or a promise provided by the producer
  async function loadViaScriptAndWait(url, { timeout = 4000, pollInterval = 100 } = {}) {
    const GLOBAL_KEYS = [
      "REMOTE_URLS","REMOTE_DATA","REMOTE_ARRAY",
      "FETCH_JS_DATA","FETCH_DATA",
      "urls","items","pins","PIN_IDS"
    ];

    return new Promise((resolve) => {
      let script = document.createElement('script');
      script.async = true;
      script.src = url;

      let finished = false;
      let timer = null;

      // Handler for producer event
      function onProducerEvent(e) {
        if (finished) return;
        finished = true;
        cleanup();
        const urls = (e && e.detail && Array.isArray(e.detail.urls)) ? e.detail.urls.slice() : [];
        resolve(urls);
      }

      // Polling after onload to detect globals
      function startPolling() {
        const start = Date.now();
        (function poll() {
          if (finished) return;
          // check for window.FETCH_JS_READY promise first
          if (window.FETCH_JS_READY instanceof Promise) {
            // try to await it (but not block poll)
            window.FETCH_JS_READY.then((res) => {
              if (finished) return;
              finished = true;
              cleanup();
              if (Array.isArray(res)) return resolve(res.slice());
              // otherwise fallthrough to check globals
            }).catch(() => {});
          }
          // check known globals
          for (const k of GLOBAL_KEYS) {
            const val = window[k];
            if (Array.isArray(val) && val.length) {
              finished = true;
              cleanup();
              return resolve(val.slice());
            }
          }
          if (Date.now() - start >= timeout) {
            finished = true;
            cleanup();
            return resolve([]); // timed out
          }
          setTimeout(poll, pollInterval);
        })();
      }

      function cleanup() {
        try { window.removeEventListener('remoteUrlsReady', onProducerEvent); } catch(e){}
        if (timer) { clearTimeout(timer); timer = null; }
        try { if (script && script.parentNode) script.parentNode.removeChild(script); } catch(e){}
      }

      script.onerror = () => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      };

      script.onload = () => {
        // producer might dispatch 'remoteUrlsReady' or set FETCH_JS_READY or globals.
        // start polling to catch them.
        startPolling();
      };

      window.addEventListener('remoteUrlsReady', onProducerEvent, { once: true });
      document.head.appendChild(script);

      // As a safety, ensure we resolve after an absolute timeout even if onload never fires.
      timer = setTimeout(() => {
        if (finished) return;
        finished = true;
        cleanup();
        resolve([]);
      }, timeout + 1000);
    });
  }

  // Keep original behavior of trying each URL in order (shuffled)
  shuffle(fetchURLs);

  for (const u of fetchURLs) {
    try {
      console.log("ðŸ”Ž Trying to fetch URL list from:", u);
      const path = u.split('?')[0].toLowerCase();

      // 1) JSON path (exact original behavior)
      if (path.endsWith('.json')) {
        try {
          const r = await fetch(u);
          if (!r.ok) throw new Error('HTTP ' + r.status);
          const json = await r.json();
          const arr = extractFromJSON(json);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from JSON:', u);
            return;
          } else {
            console.warn('âš  JSON fetched but no array found:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  JSON fetch failed:', u, e && e.message);
          continue;
        }
      }

      // 2) JS / MJS path: try module import first, then script fallback
      if (path.endsWith('.js') || path.endsWith('.mjs')) {
        // Try module (requires CORS)
        let triedModule = false;
        try {
          triedModule = true;
          const r = await fetch(u);
          if (r.ok) {
            const txt = await r.text();
            try {
              const mod = await importModuleFromText(txt);
              const arr = await extractFromModule(mod);
              if (arr.length) {
                fetchData.length = 0;
                fetchData.push(...arr);
                console.log('âœ… Loaded', arr.length, 'URLs from JS module:', u);
                return;
              } else {
                console.warn('âš  Module imported but exported no usable array:', u);
              }
            } catch (imErr) {
              console.warn('âš  Module import failed (will fallback to script):', u, imErr && imErr.message);
            }
          } else {
            console.warn('âš  Fetching JS text failed (HTTP):', u);
          }
        } catch (e) {
          if (triedModule) console.warn('âš  Fetch for module text failed, will fallback to script:', u, e && e.message);
        }

        // Script fallback with retries/backoff
        try {
          const ATTEMPTS = 3;
          let final = [];
          for (let attempt = 1; attempt <= ATTEMPTS; attempt++) {
            if (attempt > 1) await wait((attempt - 1) * 250);
            const arr = await loadViaScriptAndWait(u, { timeout: 2000 + attempt * 1000, pollInterval: 120 });
            if (Array.isArray(arr) && arr.length) { final = arr; break; }
          }
          if (final.length) {
            fetchData.length = 0;
            fetchData.push(...final);
            console.log('âœ… Loaded', final.length, 'URLs from JS script (fallback):', u);
            return;
          } else {
            console.warn('âš  JS script fallback returned no data after retries:', u);
            continue;
          }
        } catch (e) {
          console.warn('âš  Script fallback error for', u, e && e.message);
          continue;
        }
      }

      // 3) Unknown extension: try JSON then JS fallback
      try {
        const r = await fetch(u);
        if (r.ok) {
          const maybeJson = await r.json().catch(()=>null);
          const arr = extractFromJSON(maybeJson);
          if (arr.length) {
            fetchData.length = 0;
            fetchData.push(...arr);
            console.log('âœ… Loaded', arr.length, 'URLs from fallback JSON:', u);
            return;
          }
        }
      } catch(_) {}

      // fallback script attempt
      try {
        const arr = await loadViaScriptAndWait(u, { timeout: 3500 });
        if (Array.isArray(arr) && arr.length) {
          fetchData.length = 0;
          fetchData.push(...arr);
          console.log('âœ… Loaded', arr.length, 'URLs from fallback JS:', u);
          return;
        } else {
          console.warn('âš  Unknown resource had no usable data:', u);
        }
      } catch (e) {
        console.warn('âš  Unknown resource script fallback failed:', u, e && e.message);
      }

    } catch (err) {
      console.warn('âš  Failed to load', u, err && err.message);
    }
  }

  console.warn('âš  Using fallback URLs (no remote array loaded). fetchData length:', fetchData.length);
}

/* ============================================================
   (rest of your original code remains unchanged)
   ============================================================ */

function buildMap(url) {
    const p = new URL(url);
    const parts = p.hostname.split('.');
    const ln = parts.length;

    /**
     * buildMap creates a dictionary of reusable placeholders for template replacement.
     *
     * Example for URL: https://www.example.co.uk/path/page?x=1#section
     * -------------------------------------------------------------
     * PROTOCOL         â†’ "https:"
     * SUBDOMAIN        â†’ "www."
     * DOMAINNAME       â†’ "example"
     * TLD              â†’ "co.uk"
     * HOST             â†’ "www.example.co.uk"
     * PORT             â†’ "" or ":8080" if defined
     * PATH             â†’ "/path/page"
     * QUERY            â†’ "?x=1"
     * PARAMS           â†’ "x=1"
     * FRAGMENT         â†’ "#section"
     * URL              â†’ "https://www.example.co.uk/path/page?x=1#section"
     * DOMAIN           â†’ "www.example.co.uk"
     * NOPROTOCOL_URL   â†’ "www.example.co.uk/path/page?x=1#section"
     * NOSUBDOMAIN_URL  â†’ "example.co.uk/path/page?x=1#section"
     * ID               â†’ YouTube video ID if extracted externally
     */

    const hostnameNoWWW = p.hostname.replace(/^www\./i, '');
    let map = {
        PROTOCOL: p.protocol,
        SUBDOMAIN: ln > 2 ? parts.slice(0, ln - 2).join('.') + '.' : '',
        DOMAINNAME: parts[ln - 2] || '',
        TLD: parts[ln - 1] || '',
        HOST: p.hostname,
        PORT: p.port ? ':' + p.port : '',
        PATH: p.pathname,
        QUERY: p.search,
        PARAMS: p.search ? p.search.slice(1) : '',
        FRAGMENT: p.hash,
        URL: url,
        DOMAIN: p.hostname,
        NOPROTOCOL_URL: `${p.hostname}${p.pathname}${p.search}${p.hash}`,
        NOSUBDOMAIN_URL: `${hostnameNoWWW}${p.pathname}${p.search}${p.hash}`,
		
        SHORT_CODE: randomURL(shortArchiveCodes)
    };
    Object.keys(map).forEach(k => {
        try {
            map['ENCODE_' + k] = encodeURIComponent(map[k]);
        } catch {
            map['ENCODE_' + k] = '';
        }
    });
    return map;
}
function replacePlaceholders(tpl, map) {
    return tpl.replace(/(\{\{|\[)\s*(ENCODE_)?([A-Z0-9_]+)\s*(\}\}|\])/gi,
        (match, open, encPrefix, key, close, offset, fullStr) => {
            if (!key) return '';
            key = key.toUpperCase();
            const wantsEncode = !!encPrefix;
            if (wantsEncode) {
                const encodedKey = 'ENCODE_' + key;
                if (map.hasOwnProperty(encodedKey)) return map[encodedKey];
                try {
                    return encodeURIComponent(map[key] || '');
                } catch {
                    return '';
                }
            }
            if (key === 'URL') {
                const before = fullStr.slice(Math.max(0, offset - 30), offset).toLowerCase();
                if (/\burl\s*=\s*$/.test(before) || /\burl\s*=\s*/i.test(fullStr)) {
                    try {
                        return encodeURIComponent(map['URL'] || '');
                    } catch {
                        return map['URL'] || '';
                    }
                }
            }
            return map[key] || '';
        });
}

function generateUrl(tpl, normUrl) {
    if (!tpl) return '';
    tpl = tpl
        .replace(/%5B\s*(ENCODE_)?([A-Z0-9_]+)\s*%5D/gi, '[$1$2]')
        .replace(/&#(?:x5b|91);\s*(ENCODE_)?([A-Z0-9_]+)\s*&#(?:x5d|93);/gi, '[$1$2]')
        .replace(/\{\{\s*(ENCODE_)?([A-Z0-9_]+)\s*\}\}/gi, '[$1$2]')
        .replace(/%7B%7B\s*(ENCODE_)?([A-Z0-9_]+)\s*%7D%7D/gi, '[$1$2]');
    const map = buildMap(normUrl);
    return replacePlaceholders(tpl, map);
}


const shortArchiveCodes = [
	"ukoob9",
	"a6clw0",
	"z0ymol",
	"yvklwa",
	"mulldj",
	"m8ix6c",
	"j27wsc",
	"wexhwe",
	"4wtsed",
	"rrxb5f",
	"43i8f6",
	"toytti",
	"2plxxt",
	"vhev1e",
	"1bt8ew",
	"iw7otm",
	"y4levc",
	"nfewxi",
	"93b0ab",
	"y0vei5",
	"ou4avq",
	"92ua6u",
	"b5yh3i",
	"g5ua0e",
	"byeg58",
	"tsy7a0",
	"r47bfm",
	"qfpf1n",
	"88qmdi",
	"o0n0bj",
	"p8ljkr",
	"ah1aim",
	"wx39nj",
	"gzbtpn",
	"iy9vj5",
	"qt24fs",
	"ichp0i",
	"htpr6t",
	"68zbuf",
	"8v9j3g",
	"jss18o",
	"6vtohx",
	"chtd69",
	"2vw3md",
	"etanja",
	"jpx7dd",
	"rwhnyi",
	"qtrlca",
	"eryks6",
	"tnh7bh",
	"ypou27",
	"jkt2qj",
	"r1jv5u",
	"oyf3e9",
	"13cqwd",
	"nitgds",
	"83dnt5",
	"gka46z",
	"kv5jcg",
	"t54mi5",
	"jhkony",
	"exzm53",
	"yxe8pz",
	"t2qv7y",
	"f3dskz",
	"76tamp"
];
const templates = [
    "https://archive.st/?error=Archived&URL=[ENCODE_URL]&short=[SHORT_CODE]",
  	"https://megalodon.jp/pc/main?url=[ENCODE_URL]"
];

function generateTargetURL() {
  if (!fetchData.length) return "";
  
  const normUrl = randomURL(fetchData);
  const template = randomURL(templates);
  
  const finalUrl = generateUrl(template, normUrl);
  
  return normalizeURL(finalUrl);
}

/* Archive site definitions */
const ARCHIVE_SITES = [
    [
        {
          name: "Wayback",
          action: "https://web.archive.org/save",
          method: "POST",
          inputName: "url",
          extraParams: {}
        }
    ],
    [
        {
          name: "archive.today",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.li",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.vn",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.fo",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.md",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        },
        {
          name: "archive.ph",
          action: "https://archive.today/submit/",
          method: "GET",
          inputName: "url",
          extraParams: { anyway: "1" }
        }
    ]
	/*
    [
        {
          name: "GhostArchive",
          //action: "https://ghostarchive.org/archive2",
          action: "https://ghostarchive.org/archive",
          method: "POST",
          inputName: "archive",
          extraParams: {}
        }
    ]
	*/
];

function chooseRandomArchive() {
     const randomArray = ARCHIVE_SITES[Math.floor(Math.random() * ARCHIVE_SITES.length)];
     return randomArray[Math.floor(Math.random() * randomArray.length)];
}

function ensureContainer() {
  return document.body || document.documentElement;
}

function buildAndSubmitArchiveForm(site, targetUrl, targetFrameName) {
  if (!site || !targetUrl) return;
  try {
    const form = document.createElement("form");
    form.style.display = "none";
    form.method = site.method || "POST";
    form.action = site.action;
    if (targetFrameName) form.target = targetFrameName;
    else form.target = "_self";

    const urlInput = document.createElement("input");
    urlInput.type = (site.method === "GET") ? "text" : "hidden";
    urlInput.name = site.inputName || "url";
    urlInput.value = targetUrl;
    form.appendChild(urlInput);

    if (site.extraParams) {
      for (const [k, v] of Object.entries(site.extraParams)) {
        const inp = document.createElement("input");
        inp.type = "hidden";
        inp.name = k;
        inp.value = v;
        form.appendChild(inp);
      }
    }

    const container = ensureContainer();
    container.appendChild(form);
    console.log(`ðŸ“¨ Submitting to ${site.name} (${site.action}) via ${site.method} target=${form.target} url=${targetUrl}`);
    form.submit();
    setTimeout(() => { try { form.remove(); } catch(e){} }, 1000);
  } catch (err) {
    console.error("âŒ buildAndSubmitArchiveForm error:", err);
  }
}

function submitToArchiveInFrame(iframe) {
  try {
    const targetUrl = generateTargetURL();
    if (!targetUrl || !isValidURL(targetUrl)) {
      console.warn("âš  Skipping invalid target:", targetUrl);
      return;
    }
    const site = chooseRandomArchive();
    buildAndSubmitArchiveForm(site, targetUrl, iframe.name);
  } catch (err) {
    console.error("âŒ submitToArchiveInFrame error:", err);
  }
}

function createIframe(i, container) {
  try {
    const iframe = document.createElement("iframe");
    const fname = "hiddenFrame" + i;
    iframe.setAttribute("name", fname);
    iframe.setAttribute("id", fname);
    iframe.classList.add("hidden-iframe");
    iframe.style.width = "100%";
    iframe.style.height = "200px";
    iframe.style.border = "0";
    iframe.src = "about:blank";

    container.appendChild(iframe);

    setTimeout(() => submitToArchiveInFrame(iframe), 250);

    setInterval(() => {
      console.log("â± Interval firing for iframe:", fname);
      submitToArchiveInFrame(iframe);
    }, SUBMIT_INTERVAL);
  } catch (err) {
    console.error("âŒ createIframe error:", err);
  }
}

function submitToArchiveRedirect(url) {
  if (!url || !isValidURL(url)) {
    console.warn("âš  Invalid or empty URL for redirect submission:", url);
    return;
  }
  const site = chooseRandomArchive();
  buildAndSubmitArchiveForm(site, url, "_self");
}

function inIframe() {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

document.addEventListener('DOMContentLoaded', async () => {
  try {
    await updateDefaultURLs();
  } catch (e) {
    console.warn("updateDefaultURLs() failed:", e && e.message);
  }

/*
  if (inIframe()) {
	const container = ensureContainer();
    for (let i = 0; i < IFRAME_COUNT; i++) {
      createIframe(i, container);
    }
  } else {
    submitToArchiveRedirect(generateTargetURL());
  }
*/
	const container = ensureContainer();
    for (let i = 0; i < IFRAME_COUNT; i++) {
      createIframe(i, container);
    }

});
</script>
